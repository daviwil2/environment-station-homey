// ./lib/device.js used by the device.js files

'use strict';

const Homey  = require('homey');
const mqtt   = require('mqtt');
const { ManagerSettings } = require('homey'); // get the ManagerSettings object which gives access to the methods to read and write settings

/// declare variables

var client           = {}; // object to hold the MQTT conenction
var settings         = {}; // object to hold the server (App, not device) settings retrieved from the Homey ManagerSettings API; these are not the per-device Advanced Settings

var settings, topics, rootTopic, capabilities, capability;

// populate the settings object from Homey's ManagerSettings; these are the app settings that define the MQTT server, credentials, etc.
function _getSettings(){
  var keys = ManagerSettings.getKeys();
  keys.forEach(function(key){
    settings[key] = ManagerSettings.get(key)
  }); // keys.forEach
}; // _getSettings

// add event handler that is fired when server settings change, to repopulate the local object
ManagerSettings.on('set', function(key){
  _getSettings();
}); // ManagerSettings.on

const ROOT_TOPIC       = 'environment-station';
const TYPE             = 'environment-station';
const SUB_TOPICS       = ['timestamp', 'pressure', 'light', 'temperature', 'humidity', 'PM1.0', 'PM2.5', 'PM10', 'UVA', 'UVB', 'UVIndex', 'battery_voltage', 'battery_percentage'];

 // the MAX17043 Battery Fuel Gauge provides a voltage reading but the Homey UI uses just percentage for the status tab
 // format of key:value is MQTTsubtopic:HomeyCapabilityName
const CAPABILITIES_MAP = {
  "timestamp"          : 'timestamp', // custom capability
  "pressure"           : 'measure_pressure',
  "light"              : 'measure_luminance',
  "temperature"        : 'measure_temperature',
  "humidity"           : 'measure_humidity',
  "PM1.0"              : 'measure_pm1', // custom capability
  "PM2.5"              : 'measure_pm25',
  "PM10"               : 'measure_pm10', // custom capability
  "UVA"                : 'measure_uva', // custom capability
  "UVB"                : 'measure_uvb', // custom capability
  "UVIndex"            : 'measure_uvi', // custom capability, replaces native measure_ultraviolet for UI consistency with UV/A and /B
  "battery_percentage" : 'measure_battery' // shows on separate tab, not with the sensor icons/values
};

module.exports = class EnvironmentStationDevice extends Homey.Device {

  /// helper functions

  _formatTimestamp(epochSeconds){

    let ms = epochSeconds * 1000; // convert seconds to milliseconds
    let rawDateObject = new Date(ms); // convert milliseconds to a JavaScript date object

    let adjustment = rawDateObject.getTimezoneOffset() * 60 * 1000; // get the timezone offset vs. UTC in milliseconds
    let dateObject = new Date(ms + adjustment); // create a new date object adjusted for the timezone

    let day = dateObject.getDate().toString();
    let month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][dateObject.getMonth()];
    let year = dateObject.getFullYear().toString().slice(-2); // extract the last two characters of the 4-character year string
    let hours = dateObject.getHours().toString();
    let minutes = dateObject.getMinutes().toString();
    minutes = (minutes.length === 1) ? '0'+minutes : minutes ; // pad with leading 0 if necessary

    return hours+':'+minutes; // was return day+'-'+month+'-'+year+' at '+hours+':'+minutes;

  }; // _formatTimestamp

  _log(message){
    if (process.env.DEBUG === '1'){ this.log(message) };
  }; // _log

  /// handlers for events generated by Homey

  // called when the Device is loaded and properties such as name, capabilities and state are available
  onInit(){

    /// code for onInit() starts here

    // call the function getType() passed from the device.js file for this specific device that returns a it's type as a string
    this.type = this.getType();

    // validate that type is specified and valid
    if (this.type !== TYPE){
      throw new Error('invalid or missing type passed to onPair in ./lib/device.js')
    }; //if

    // populate the settings object with the server address, connection credentials and topic so we can connect to the MQTT server
    _getSettings();

    // check that we have a settings.topic
    if (!settings.topic){
      throw new Error('topic not populated, cannot connect to server and subscribe to topic')
    }; // if

    // ensure that the topic doesn't contain a /, + or #
    if (/[/+#]/g.test(settings.topic)){
      throw new Error('invalid characters in settings.topic');
    }; // if

    // build the full root topic path
    rootTopic = ROOT_TOPIC + '/' + settings.topic + '/';

    // build an array of topics to which we will unsubscribe
    topics = SUB_TOPICS.map((topic) => { return rootTopic + topic });

    // if we have a username and password then construct a connection object to connect to the MQTTserver
    let options = {};
    if (settings.username && settings.password){
      options.username = settings.username;
      options.password = settings.password;
    }; // if

    this._log('connecting to MQTT server at mqtt://'+settings.server+':'+settings.port);

    // attempt to connect to the MQTT server
    client = mqtt.connect('mqtt://'+settings.server+':'+settings.port, options);

    /// event handlers for the MQTT client events

    // define event handler for MQTT 'connect' events
    client.on('connect', function(){

      let message = (topics.length === 1) ? ' topic' : ' topics' ;
      this._log('connected to MQTT server, now subscribing to '+topics.length+message);

      // as we've successfully connected to the MQTT server we can subscribe to the topics for this device
      client.subscribe(topics, {}, function(err, granted){});

    }.bind(this)); // client.on connect

    // define event handler for MQTT 'message' events which are emitted when the MQTT client receives a publish packet
    // we use these to set capability states for the device; e.g. for a double relay switch getCapabilities() returns [ 'onoff.1', 'onoff.2' ]
    // if changing settings using the Homey app then these will get called but are unnecessary as Homey will update
    // the relevant capability automatically; where these handlers are needed are where the device is changed outside
    // of Homey e.g. using another app or via it's web UI
    client.on('message', function(topic, message, packet){

      topic            = topic.split('/'); // split the string into an array using '/' as the delimiter
      message          = message.toString(); // message is a Buffer, so convert to string for display
      capabilities     = this.getCapabilities();

      // map the topic[2] to the correct Homey capability
      capability = (CAPABILITIES_MAP[topic[2]]);

      // store the value from the message using Homey's setCapabilityValue if it is a valid capability
      if (capability && capabilities.includes(capability)){

        message = Number(message); // everything is a number

        // if timestamp convert epoch seconds to milliseconds then to ISO8601
        if (capability === 'timestamp'){ message = this._formatTimestamp.call(this, message) };

        // if UVIndex then convert WM^2 to UV Index range [0-16]
        if (capability === 'UVIndex'){ message = (message * 40).toFixed(1) };

        this._log('message received: '+capability+' value '+message);

        this.setCapabilityValue(capability, message)
        .then(() => {})
        .catch((err) => {});

      }; // if (capability)

    }.bind(this)); // client.on message

    // define event handler for MQTT 'reconnect' events
    client.on('reconnect', function(){});

    // define event handler for MQTT 'error' events
    client.on('error', function(err){
      this._log('MQTT client error: '+err.message);
      client.end(); // close the MQTT connection
    }); // client.on error

  }; // onInit

  // called when the user deletes the device
  onDeleted(){
    if (client && client.end){ client.end() }; // terminate the MQTT client if client and the client.end function are available
  }; // onDeleted

  // called when the user updates the device's Advanced Settings in the client; overwrite the method to approve or reject the new settings.
  // oldSettings and newSettings are objects with the settings blocks, changedKeys is an array of keys changed since the previous version
  onSettings(oldSettings, newSettings, changedKeys, callback){

    this._log('onSettings() in ./lib/device.js called');

    // if the setting MQTTtopic has changed...
    if (changedKeys.indexOf('MQTTtopic') !== -1){

      // trap for the topic containing a '/'; this shouldn't happen as the RegEx should stop it
      if (newSettings.topic.indexOf('/') !== -1 || newSettings.topic.indexOf('+') !== -1){
        return callback(new RangeError('MQTT topic contains one or more invalid characters'), null);
      }; // if

      // unsubscribe from the old topics
      client.unsubscribe(topics, function(err){

        if (err){ return callback(err, null) };

        // update with new string
        this.setSettings( {'MQTTtopic': newSettings.topic} );

        // update the topics array with the new MQTT server
        topics = topics.map(function(topic){
          topic = topic.split('/'); // split into an array delimited with '/'
          topic[0] = newSettings.topic;
          topic = topic.join('/'); // recombine the array into a string
          return topic; // update the array with the new topic
        }); // topics.map

        // subscribe to the MQTT topics, that array now updated with the new server name
        client.subscribe(topics, {}, function(err, granted){
          if (err){ return callback(err, null) };
          return callback(null); // to signal no error
        }); // client.subscribe

      }); // client.unsubscribe

    }; // if (changedKeys...)

    // catch all
    return callback(null); // to signal no error

  }; // onSettings

}; // module.exports
